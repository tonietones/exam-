{
  "version": 4,
  "terraform_version": "1.4.2",
  "serial": 4,
  "lineage": "1b16327a-0b18-45e8-2d71-a879b3fc8e4b",
  "outputs": {},
  "resources": [
    {
      "mode": "data",
      "type": "aws_eks_cluster",
      "name": "demo",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "arn": "arn:aws:eks:us-east-1:249042606135:cluster/demo",
            "certificate_authority": [
              {
                "data": "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUMvakNDQWVhZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKY201bGRHVnpNQjRYRFRJek1ETXhOekV4TURJeU9Wb1hEVE16TURNeE5ERXhNREl5T1Zvd0ZURVRNQkVHQTFVRQpBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTW9xCkxqWndPSDcrbnMvVzFJUXluL0xWVXdkUzdkMndrZUZzY0kwelhGL2lybUYzVmJMUThZV05Bb3c0RzdTMmRLaE0KdlZiTDdnY2N2S0FlWm9XM1MyMmFjTjc0UU9TMy80VGhWRXRZQ0VMc3NhWmVCeG45bUgwRUFiNWptd05zT1BhSwpvczhBYVJBVzVqWCt4UFF6d3Z1cTR1RURSOHlPU2JDeWc0SEdQNFpWeGg0SlBlakJIL2dqSC9qSW90Zm9tSUJRCmhnZi84S3lDREhKOTJJSWw4bkgxSWZ4OUhza0ZtckY2dnZHdjBUNm1tQTRzMCs2T1dPT1VmMjFwdzhpU2NKNDAKcVJzVHArNkFkalRmdHplTlkyQUE0M3A1STkvb1JQWXUwdDd5alBxNGlpZFMrNmRqTnhnTFhzaHRLZTJQd3VsQgp0OEZQSXJ5TU1tTkNnd0YraEcwQ0F3RUFBYU5aTUZjd0RnWURWUjBQQVFIL0JBUURBZ0trTUE4R0ExVWRFd0VCCi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZGS3o3L0I0QzA3SSs2K0FBY0tIMnkvUVJBSHZNQlVHQTFVZEVRUU8KTUF5Q0NtdDFZbVZ5Ym1WMFpYTXdEUVlKS29aSWh2Y05BUUVMQlFBRGdnRUJBS0tGVmZBVFFWcExFQU9jQzh5UgpZNHlPMkFocFc4VlByeWlhTERMRmRrYVdNS0lWVVpiV2RHYnF3aEEyMnZ1K29vVWVIMkp3S1R5RStsaFpDRnBSCkxvVGVFeVdtbmwyMzV1OXJ2S3JHczFWYk9YamcrT3h1Sy9ZRFJNQTJSZHdML0puL3JzZlFFb3ZoaSsyTTAydE0KTXpJQlY1Wk0xMDhxOFQwSE1OYXF1akgrUlhDdHQwS3RiYk5CdmJncGlpaHRndVh5ZWZlYnc3N1ZUcGpKaDIrWQptTG15R0hzTDlid0V0MXozZWJ0NjRGb2h2RmkrM01iZ3JMaHAxa1JSM0h5Sk5mbDhwaGFlVXNOQzZ3bnNMa3FaCnlLR0MvTGs2UTdZWWw3Nm90eDUrNHI5bEc1Ly9qUE9xaW1PUWlUNXF0YnR3YmVoTDRUVnF6Q3NtY3pPYnNsancKVEp3PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg=="
              }
            ],
            "cluster_id": null,
            "created_at": "2023-03-17 10:55:56.465 +0000 UTC",
            "enabled_cluster_log_types": [],
            "endpoint": "https://2C67DB241227BCC60469936B2788D027.gr7.us-east-1.eks.amazonaws.com",
            "id": "demo",
            "identity": [
              {
                "oidc": [
                  {
                    "issuer": "https://oidc.eks.us-east-1.amazonaws.com/id/2C67DB241227BCC60469936B2788D027"
                  }
                ]
              }
            ],
            "kubernetes_network_config": [
              {
                "ip_family": "ipv4",
                "service_ipv4_cidr": "172.20.0.0/16",
                "service_ipv6_cidr": ""
              }
            ],
            "name": "demo",
            "outpost_config": [],
            "platform_version": "eks.1",
            "role_arn": "arn:aws:iam::249042606135:role/eks-cluster-demo",
            "status": "ACTIVE",
            "tags": {},
            "version": "1.25",
            "vpc_config": [
              {
                "cluster_security_group_id": "sg-087e8f1974e7506da",
                "endpoint_private_access": false,
                "endpoint_public_access": true,
                "public_access_cidrs": [
                  "0.0.0.0/0"
                ],
                "security_group_ids": [],
                "subnet_ids": [
                  "subnet-01e706db0d87a7146",
                  "subnet-036c36b62816049a1",
                  "subnet-09f03da0502fe7b7d",
                  "subnet-0dc4f0ffc9fadc325"
                ],
                "vpc_id": "vpc-01dc850ff6d9b5d00"
              }
            ]
          },
          "sensitive_attributes": []
        }
      ]
    },
    {
      "mode": "data",
      "type": "aws_eks_cluster_auth",
      "name": "demo_auth",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "demo_auth",
            "name": "demo_auth",
            "token": "k8s-aws-v1.aHR0cHM6Ly9zdHMuYW1hem9uYXdzLmNvbS8_QWN0aW9uPUdldENhbGxlcklkZW50aXR5JlZlcnNpb249MjAxMS0wNi0xNSZYLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFUVDdBWVRBM1hGU0dYTlNEJTJGMjAyMzAzMTglMkZ1cy1lYXN0LTElMkZzdHMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIzMDMxOFQyMjA5NTlaJlgtQW16LUV4cGlyZXM9MCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QlM0J4LWs4cy1hd3MtaWQmWC1BbXotU2lnbmF0dXJlPTNjOTdhY2RjMDcxOWQ0Y2U5MTNmMTc5YWI1OGVhNDk5ODMyZTU4NmM4YTU0ZWFhOTViZWJmOWIyODgxMmI5MGU"
          },
          "sensitive_attributes": []
        }
      ]
    },
    {
      "mode": "managed",
      "type": "helm_release",
      "name": "ingress_nginx",
      "provider": "provider[\"registry.terraform.io/hashicorp/helm\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "atomic": false,
            "chart": "ingress-nginx",
            "cleanup_on_fail": false,
            "create_namespace": true,
            "dependency_update": false,
            "description": null,
            "devel": null,
            "disable_crd_hooks": false,
            "disable_openapi_validation": false,
            "disable_webhooks": false,
            "force_update": false,
            "id": "ingress-nginx",
            "keyring": null,
            "lint": false,
            "manifest": null,
            "max_history": 0,
            "metadata": [
              {
                "app_version": "1.6.4",
                "chart": "ingress-nginx",
                "name": "ingress-nginx",
                "namespace": "nginx-ingress",
                "revision": 1,
                "values": "{\"commonLabels\":{},\"controller\":{\"addHeaders\":{},\"admissionWebhooks\":{\"annotations\":{},\"certManager\":{\"admissionCert\":{\"duration\":\"\"},\"enabled\":false,\"rootCert\":{\"duration\":\"\"}},\"certificate\":\"/usr/local/certificates/cert\",\"createSecretJob\":{\"resources\":{},\"securityContext\":{\"allowPrivilegeEscalation\":false}},\"enabled\":true,\"existingPsp\":\"\",\"extraEnvs\":[],\"failurePolicy\":\"Fail\",\"key\":\"/usr/local/certificates/key\",\"labels\":{},\"namespaceSelector\":{},\"networkPolicyEnabled\":false,\"objectSelector\":{},\"patch\":{\"enabled\":true,\"image\":{\"digest\":\"sha256:39c5b2e3310dc4264d638ad28d9d1d96c4cbb2b2dcfb52368fe4e3c63f61e10f\",\"image\":\"ingress-nginx/kube-webhook-certgen\",\"pullPolicy\":\"IfNotPresent\",\"registry\":\"registry.k8s.io\",\"tag\":\"v20220916-gd32f8c343\"},\"labels\":{},\"nodeSelector\":{\"kubernetes.io/os\":\"linux\"},\"podAnnotations\":{},\"priorityClassName\":\"\",\"securityContext\":{\"fsGroup\":2000,\"runAsNonRoot\":true,\"runAsUser\":2000},\"tolerations\":[]},\"patchWebhookJob\":{\"resources\":{},\"securityContext\":{\"allowPrivilegeEscalation\":false}},\"port\":8443,\"service\":{\"annotations\":{},\"externalIPs\":[],\"loadBalancerSourceRanges\":[],\"servicePort\":443,\"type\":\"ClusterIP\"}},\"affinity\":{},\"allowSnippetAnnotations\":true,\"annotations\":{},\"autoscaling\":{\"annotations\":{},\"apiVersion\":\"autoscaling/v2\",\"behavior\":{},\"enabled\":false,\"maxReplicas\":11,\"minReplicas\":1,\"targetCPUUtilizationPercentage\":50,\"targetMemoryUtilizationPercentage\":50},\"autoscalingTemplate\":[],\"config\":{},\"configAnnotations\":{},\"configMapNamespace\":\"\",\"containerName\":\"controller\",\"containerPort\":{\"http\":80,\"https\":443},\"customTemplate\":{\"configMapKey\":\"\",\"configMapName\":\"\"},\"dnsConfig\":{},\"dnsPolicy\":\"ClusterFirst\",\"electionID\":\"\",\"enableMimalloc\":true,\"enableTopologyAwareRouting\":false,\"existingPsp\":\"\",\"extraArgs\":{},\"extraContainers\":[],\"extraEnvs\":[],\"extraInitContainers\":[],\"extraModules\":[],\"extraVolumeMounts\":[],\"extraVolumes\":[],\"healthCheckHost\":\"\",\"healthCheckPath\":\"/healthz\",\"hostNetwork\":false,\"hostPort\":{\"enabled\":false,\"ports\":{\"http\":80,\"https\":443}},\"hostname\":{},\"image\":{\"allowPrivilegeEscalation\":true,\"chroot\":false,\"digest\":\"sha256:15be4666c53052484dd2992efacf2f50ea77a78ae8aa21ccd91af6baaa7ea22f\",\"digestChroot\":\"sha256:0de01e2c316c3ca7847ca13b32d077af7910d07f21a4a82f81061839764f8f81\",\"image\":\"ingress-nginx/controller\",\"pullPolicy\":\"IfNotPresent\",\"registry\":\"registry.k8s.io\",\"runAsUser\":101,\"tag\":\"v1.6.4\"},\"ingressClass\":\"nginx\",\"ingressClassByName\":false,\"ingressClassResource\":{\"controllerValue\":\"k8s.io/ingress-nginx\",\"default\":false,\"enabled\":true,\"name\":\"nginx\",\"parameters\":{}},\"keda\":{\"apiVersion\":\"keda.sh/v1alpha1\",\"behavior\":{},\"cooldownPeriod\":300,\"enabled\":false,\"maxReplicas\":11,\"minReplicas\":1,\"pollingInterval\":30,\"restoreToOriginalReplicaCount\":false,\"scaledObject\":{\"annotations\":{}},\"triggers\":[]},\"kind\":\"Deployment\",\"labels\":{},\"lifecycle\":{\"preStop\":{\"exec\":{\"command\":[\"/wait-shutdown\"]}}},\"livenessProbe\":{\"failureThreshold\":5,\"httpGet\":{\"path\":\"/healthz\",\"port\":10254,\"scheme\":\"HTTP\"},\"initialDelaySeconds\":10,\"periodSeconds\":10,\"successThreshold\":1,\"timeoutSeconds\":1},\"maxmindLicenseKey\":\"\",\"metrics\":{\"enabled\":false,\"port\":10254,\"portName\":\"metrics\",\"prometheusRule\":{\"additionalLabels\":{},\"enabled\":false,\"rules\":[]},\"service\":{\"annotations\":{},\"externalIPs\":[],\"labels\":{},\"loadBalancerSourceRanges\":[],\"servicePort\":10254,\"type\":\"ClusterIP\"},\"serviceMonitor\":{\"additionalLabels\":{},\"enabled\":false,\"metricRelabelings\":[],\"namespace\":\"\",\"namespaceSelector\":{},\"relabelings\":[],\"scrapeInterval\":\"30s\",\"targetLabels\":[]}},\"minAvailable\":1,\"minReadySeconds\":0,\"name\":\"controller\",\"nodeSelector\":{\"kubernetes.io/os\":\"linux\"},\"opentelemetry\":{\"containerSecurityContext\":{\"allowPrivilegeEscalation\":false},\"enabled\":false,\"image\":\"registry.k8s.io/ingress-nginx/opentelemetry:v20230107-helm-chart-4.4.2-2-g96b3d2165@sha256:331b9bebd6acfcd2d3048abbdd86555f5be76b7e3d0b5af4300b04235c6056c9\"},\"podAnnotations\":{},\"podLabels\":{},\"podSecurityContext\":{},\"priorityClassName\":\"\",\"proxySetHeaders\":{},\"publishService\":{\"enabled\":true,\"pathOverride\":\"\"},\"readinessProbe\":{\"failureThreshold\":3,\"httpGet\":{\"path\":\"/healthz\",\"port\":10254,\"scheme\":\"HTTP\"},\"initialDelaySeconds\":10,\"periodSeconds\":10,\"successThreshold\":1,\"timeoutSeconds\":1},\"replicaCount\":1,\"reportNodeInternalIp\":false,\"resources\":{\"requests\":{\"cpu\":\"100m\",\"memory\":\"90Mi\"}},\"scope\":{\"enabled\":false,\"namespace\":\"\",\"namespaceSelector\":\"\"},\"service\":{\"annotations\":{},\"appProtocol\":true,\"enableHttp\":true,\"enableHttps\":true,\"enabled\":true,\"external\":{\"enabled\":true},\"externalIPs\":[],\"internal\":{\"annotations\":{},\"enabled\":false,\"loadBalancerSourceRanges\":[]},\"ipFamilies\":[\"IPv4\"],\"ipFamilyPolicy\":\"SingleStack\",\"labels\":{},\"loadBalancerIP\":\"\",\"loadBalancerSourceRanges\":[],\"nodePorts\":{\"http\":\"\",\"https\":\"\",\"tcp\":{},\"udp\":{}},\"ports\":{\"http\":80,\"https\":443},\"targetPorts\":{\"http\":\"http\",\"https\":\"https\"},\"type\":\"LoadBalancer\"},\"shareProcessNamespace\":false,\"sysctls\":{},\"tcp\":{\"annotations\":{},\"configMapNamespace\":\"\"},\"terminationGracePeriodSeconds\":300,\"tolerations\":[],\"topologySpreadConstraints\":[],\"udp\":{\"annotations\":{},\"configMapNamespace\":\"\"},\"updateStrategy\":{},\"watchIngressWithoutClass\":false},\"defaultBackend\":{\"affinity\":{},\"autoscaling\":{\"annotations\":{},\"apiVersion\":\"autoscaling/v2\",\"enabled\":false,\"maxReplicas\":2,\"minReplicas\":1,\"targetCPUUtilizationPercentage\":50,\"targetMemoryUtilizationPercentage\":50},\"containerSecurityContext\":{},\"enabled\":false,\"existingPsp\":\"\",\"extraArgs\":{},\"extraEnvs\":[],\"extraVolumeMounts\":[],\"extraVolumes\":[],\"image\":{\"allowPrivilegeEscalation\":false,\"image\":\"defaultbackend-amd64\",\"pullPolicy\":\"IfNotPresent\",\"readOnlyRootFilesystem\":true,\"registry\":\"registry.k8s.io\",\"runAsNonRoot\":true,\"runAsUser\":65534,\"tag\":\"1.5\"},\"labels\":{},\"livenessProbe\":{\"failureThreshold\":3,\"initialDelaySeconds\":30,\"periodSeconds\":10,\"successThreshold\":1,\"timeoutSeconds\":5},\"minAvailable\":1,\"minReadySeconds\":0,\"name\":\"defaultbackend\",\"nodeSelector\":{\"kubernetes.io/os\":\"linux\"},\"podAnnotations\":{},\"podLabels\":{},\"podSecurityContext\":{},\"port\":8080,\"priorityClassName\":\"\",\"readinessProbe\":{\"failureThreshold\":6,\"initialDelaySeconds\":0,\"periodSeconds\":5,\"successThreshold\":1,\"timeoutSeconds\":5},\"replicaCount\":1,\"resources\":{},\"service\":{\"annotations\":{},\"externalIPs\":[],\"loadBalancerSourceRanges\":[],\"servicePort\":80,\"type\":\"ClusterIP\"},\"serviceAccount\":{\"automountServiceAccountToken\":true,\"create\":true,\"name\":\"\"},\"tolerations\":[],\"updateStrategy\":{}},\"dhParam\":null,\"imagePullSecrets\":[],\"podSecurityPolicy\":{\"enabled\":true},\"portNamePrefix\":\"\",\"rbac\":{\"create\":true,\"scope\":false},\"revisionHistoryLimit\":10,\"server\":{\"persistentVolume\":{\"enabled\":false}},\"server.resources\":\"\\\"limits\\\":\\n  \\\"cpu\\\": \\\"200m\\\"\\n  \\\"memory\\\": \\\"50Mi\\\"\\n\\\"requests\\\":\\n  \\\"cpu\\\": \\\"100m\\\"\\n  \\\"memory\\\": \\\"30Mi\\\"\\n\",\"service\":{\"type\":\"LoadBalancer\"},\"serviceAccount\":{\"annotations\":{},\"automountServiceAccountToken\":true,\"create\":true,\"name\":\"\"},\"tcp\":{},\"udp\":{}}",
                "version": "4.5.2"
              }
            ],
            "name": "ingress-nginx",
            "namespace": "nginx-ingress",
            "pass_credentials": false,
            "postrender": [],
            "recreate_pods": false,
            "render_subchart_notes": true,
            "replace": false,
            "repository": "https://kubernetes.github.io/ingress-nginx",
            "repository_ca_file": null,
            "repository_cert_file": null,
            "repository_key_file": null,
            "repository_password": null,
            "repository_username": null,
            "reset_values": false,
            "reuse_values": false,
            "set": [
              {
                "name": "podSecurityPolicy.enabled",
                "type": "",
                "value": "true"
              },
              {
                "name": "server.persistentVolume.enabled",
                "type": "",
                "value": "false"
              },
              {
                "name": "server\\.resources",
                "type": "",
                "value": "\"limits\":\n  \"cpu\": \"200m\"\n  \"memory\": \"50Mi\"\n\"requests\":\n  \"cpu\": \"100m\"\n  \"memory\": \"30Mi\"\n"
              },
              {
                "name": "service.type",
                "type": "",
                "value": "LoadBalancer"
              }
            ],
            "set_sensitive": [],
            "skip_crds": false,
            "status": "deployed",
            "timeout": 300,
            "values": [
              "## nginx configuration\n## Ref: https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/index.md\n##\n\n## Overrides for generated resource names\n# See templates/_helpers.tpl\n# nameOverride:\n# fullnameOverride:\n\n## Labels to apply to all resources\n##\ncommonLabels: {}\n# scmhash: abc123\n# myLabel: aakkmd\n\ncontroller:\n    name: controller\n    image:\n        ## Keep false as default for now!\n        chroot: false\n        registry: registry.k8s.io\n        image: ingress-nginx/controller\n        ## for backwards compatibility consider setting the full image url via the repository value below\n        ## use *either* current default registry/image or repository format or installing chart by providing the values.yaml will fail\n        ## repository:\n        tag: \"v1.6.4\"\n        digest: sha256:15be4666c53052484dd2992efacf2f50ea77a78ae8aa21ccd91af6baaa7ea22f\n        digestChroot: sha256:0de01e2c316c3ca7847ca13b32d077af7910d07f21a4a82f81061839764f8f81\n        pullPolicy: IfNotPresent\n        # www-data -\u003e uid 101\n        runAsUser: 101\n        allowPrivilegeEscalation: true\n    # -- Use an existing PSP instead of creating one\n    existingPsp: \"\"\n    # -- Configures the controller container name\n    containerName: controller\n    # -- Configures the ports that the nginx-controller listens on\n    containerPort:\n        http: 80\n        https: 443\n    # -- Will add custom configuration options to Nginx https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/\n    config: {}\n    # -- Annotations to be added to the controller config configuration configmap.\n    configAnnotations: {}\n    # -- Will add custom headers before sending traffic to backends according to https://github.com/kubernetes/ingress-nginx/tree/main/docs/examples/customization/custom-headers\n    proxySetHeaders: {}\n    # -- Will add custom headers before sending response traffic to the client according to: https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#add-headers\n    addHeaders: {}\n    # -- Optionally customize the pod dnsConfig.\n    dnsConfig: {}\n    # -- Optionally customize the pod hostname.\n    hostname: {}\n    # -- Optionally change this to ClusterFirstWithHostNet in case you have 'hostNetwork: true'.\n    # By default, while using host network, name resolution uses the host's DNS. If you wish nginx-controller\n    # to keep resolving names inside the k8s network, use ClusterFirstWithHostNet.\n    dnsPolicy: ClusterFirst\n    # -- Bare-metal considerations via the host network https://kubernetes.github.io/ingress-nginx/deploy/baremetal/#via-the-host-network\n    # Ingress status was blank because there is no Service exposing the NGINX Ingress controller in a configuration using the host network, the default --publish-service flag used in standard cloud setups does not apply\n    reportNodeInternalIp: false\n    # -- Process Ingress objects without ingressClass annotation/ingressClassName field\n    # Overrides value for --watch-ingress-without-class flag of the controller binary\n    # Defaults to false\n    watchIngressWithoutClass: false\n    # -- Process IngressClass per name (additionally as per spec.controller).\n    ingressClassByName: false\n    # -- This configuration enables Topology Aware Routing feature, used together with service annotation service.kubernetes.io/topology-aware-hints=\"auto\"\n    # Defaults to false\n    enableTopologyAwareRouting: false\n    # -- This configuration defines if Ingress Controller should allow users to set\n    # their own *-snippet annotations, otherwise this is forbidden / dropped\n    # when users add those annotations.\n    # Global snippets in ConfigMap are still respected\n    allowSnippetAnnotations: true\n    # -- Required for use with CNI based kubernetes installations (such as ones set up by kubeadm),\n    # since CNI and hostport don't mix yet. Can be deprecated once https://github.com/kubernetes/kubernetes/issues/23920\n    # is merged\n    hostNetwork: false\n    ## Use host ports 80 and 443\n    ## Disabled by default\n    hostPort:\n        # -- Enable 'hostPort' or not\n        enabled: false\n        ports:\n            # -- 'hostPort' http port\n            http: 80\n            # -- 'hostPort' https port\n            https: 443\n    # -- Election ID to use for status update, by default it uses the controller name combined with a suffix of 'leader'\n    electionID: \"\"\n    ## This section refers to the creation of the IngressClass resource\n    ## IngressClass resources are supported since k8s \u003e= 1.18 and required since k8s \u003e= 1.19\n    ingressClassResource:\n        # -- Name of the ingressClass\n        name: nginx\n        # -- Is this ingressClass enabled or not\n        enabled: true\n        # -- Is this the default ingressClass for the cluster\n        default: false\n        # -- Controller-value of the controller that is processing this ingressClass\n        controllerValue: \"k8s.io/ingress-nginx\"\n        # -- Parameters is a link to a custom resource containing additional\n        # configuration for the controller. This is optional if the controller\n        # does not require extra parameters.\n        parameters: {}\n    # -- For backwards compatibility with ingress.class annotation, use ingressClass.\n    # Algorithm is as follows, first ingressClassName is considered, if not present, controller looks for ingress.class annotation\n    ingressClass: nginx\n    # -- Labels to add to the pod container metadata\n    podLabels: {}\n    #  key: value\n\n    # -- Security Context policies for controller pods\n    podSecurityContext: {}\n    # -- See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for notes on enabling and using sysctls\n    sysctls: {}\n    # sysctls:\n    #   \"net.core.somaxconn\": \"8192\"\n\n    # -- Allows customization of the source of the IP address or FQDN to report\n    # in the ingress status field. By default, it reads the information provided\n    # by the service. If disable, the status field reports the IP address of the\n    # node or nodes where an ingress controller pod is running.\n    publishService:\n        # -- Enable 'publishService' or not\n        enabled: true\n        # -- Allows overriding of the publish service to bind to\n        # Must be \u003cnamespace\u003e/\u003cservice_name\u003e\n        pathOverride: \"\"\n    # Limit the scope of the controller to a specific namespace\n    scope:\n        # -- Enable 'scope' or not\n        enabled: false\n        # -- Namespace to limit the controller to; defaults to $(POD_NAMESPACE)\n        namespace: \"\"\n        # -- When scope.enabled == false, instead of watching all namespaces, we watching namespaces whose labels\n        # only match with namespaceSelector. Format like foo=bar. Defaults to empty, means watching all namespaces.\n        namespaceSelector: \"\"\n    # -- Allows customization of the configmap / nginx-configmap namespace; defaults to $(POD_NAMESPACE)\n    configMapNamespace: \"\"\n    tcp:\n        # -- Allows customization of the tcp-services-configmap; defaults to $(POD_NAMESPACE)\n        configMapNamespace: \"\"\n        # -- Annotations to be added to the tcp config configmap\n        annotations: {}\n    udp:\n        # -- Allows customization of the udp-services-configmap; defaults to $(POD_NAMESPACE)\n        configMapNamespace: \"\"\n        # -- Annotations to be added to the udp config configmap\n        annotations: {}\n    # -- Maxmind license key to download GeoLite2 Databases.\n    ## https://blog.maxmind.com/2019/12/18/significant-changes-to-accessing-and-using-geolite2-databases\n    maxmindLicenseKey: \"\"\n    # -- Additional command line arguments to pass to nginx-ingress-controller\n    # E.g. to specify the default SSL certificate you can use\n    extraArgs: {}\n    ## extraArgs:\n    ##   default-ssl-certificate: \"\u003cnamespace\u003e/\u003csecret_name\u003e\"\n\n    # -- Additional environment variables to set\n    extraEnvs: []\n    # extraEnvs:\n    #   - name: FOO\n    #     valueFrom:\n    #       secretKeyRef:\n    #         key: FOO\n    #         name: secret-resource\n\n    # -- Use a `DaemonSet` or `Deployment`\n    kind: Deployment\n    # -- Annotations to be added to the controller Deployment or DaemonSet\n    ##\n    annotations: {}\n    #  keel.sh/pollSchedule: \"@every 60m\"\n\n    # -- Labels to be added to the controller Deployment or DaemonSet and other resources that do not have option to specify labels\n    ##\n    labels: {}\n    #  keel.sh/policy: patch\n    #  keel.sh/trigger: poll\n\n    # -- The update strategy to apply to the Deployment or DaemonSet\n    ##\n    updateStrategy: {}\n    #  rollingUpdate:\n    #    maxUnavailable: 1\n    #  type: RollingUpdate\n\n    # -- `minReadySeconds` to avoid killing pods before we are ready\n    ##\n    minReadySeconds: 0\n    # -- Node tolerations for server scheduling to nodes with taints\n    ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/\n    ##\n    tolerations: []\n    #  - key: \"key\"\n    #    operator: \"Equal|Exists\"\n    #    value: \"value\"\n    #    effect: \"NoSchedule|PreferNoSchedule|NoExecute(1.6 only)\"\n\n    # -- Affinity and anti-affinity rules for server scheduling to nodes\n    ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity\n    ##\n    affinity: {}\n    # # An example of preferred pod anti-affinity, weight is in the range 1-100\n    # podAntiAffinity:\n    #   preferredDuringSchedulingIgnoredDuringExecution:\n    #   - weight: 100\n    #     podAffinityTerm:\n    #       labelSelector:\n    #         matchExpressions:\n    #         - key: app.kubernetes.io/name\n    #           operator: In\n    #           values:\n    #           - ingress-nginx\n    #         - key: app.kubernetes.io/instance\n    #           operator: In\n    #           values:\n    #           - ingress-nginx\n    #         - key: app.kubernetes.io/component\n    #           operator: In\n    #           values:\n    #           - controller\n    #       topologyKey: kubernetes.io/hostname\n\n    # # An example of required pod anti-affinity\n    # podAntiAffinity:\n    #   requiredDuringSchedulingIgnoredDuringExecution:\n    #   - labelSelector:\n    #       matchExpressions:\n    #       - key: app.kubernetes.io/name\n    #         operator: In\n    #         values:\n    #         - ingress-nginx\n    #       - key: app.kubernetes.io/instance\n    #         operator: In\n    #         values:\n    #         - ingress-nginx\n    #       - key: app.kubernetes.io/component\n    #         operator: In\n    #         values:\n    #         - controller\n    #     topologyKey: \"kubernetes.io/hostname\"\n\n    # -- Topology spread constraints rely on node labels to identify the topology domain(s) that each Node is in.\n    ## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/\n    ##\n    topologySpreadConstraints: []\n    # - maxSkew: 1\n    #   topologyKey: topology.kubernetes.io/zone\n    #   whenUnsatisfiable: DoNotSchedule\n    #   labelSelector:\n    #     matchLabels:\n    #       app.kubernetes.io/instance: ingress-nginx-internal\n\n    # -- `terminationGracePeriodSeconds` to avoid killing pods before we are ready\n    ## wait up to five minutes for the drain of connections\n    ##\n    terminationGracePeriodSeconds: 300\n    # -- Node labels for controller pod assignment\n    ## Ref: https://kubernetes.io/docs/user-guide/node-selection/\n    ##\n    nodeSelector:\n        kubernetes.io/os: linux\n    ## Liveness and readiness probe values\n    ## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes\n    ##\n    ## startupProbe:\n    ##   httpGet:\n    ##     # should match container.healthCheckPath\n    ##     path: \"/healthz\"\n    ##     port: 10254\n    ##     scheme: HTTP\n    ##   initialDelaySeconds: 5\n    ##   periodSeconds: 5\n    ##   timeoutSeconds: 2\n    ##   successThreshold: 1\n    ##   failureThreshold: 5\n    livenessProbe:\n        httpGet:\n            # should match container.healthCheckPath\n            path: \"/healthz\"\n            port: 10254\n            scheme: HTTP\n        initialDelaySeconds: 10\n        periodSeconds: 10\n        timeoutSeconds: 1\n        successThreshold: 1\n        failureThreshold: 5\n    readinessProbe:\n        httpGet:\n            # should match container.healthCheckPath\n            path: \"/healthz\"\n            port: 10254\n            scheme: HTTP\n        initialDelaySeconds: 10\n        periodSeconds: 10\n        timeoutSeconds: 1\n        successThreshold: 1\n        failureThreshold: 3\n    # -- Path of the health check endpoint. All requests received on the port defined by\n    # the healthz-port parameter are forwarded internally to this path.\n    healthCheckPath: \"/healthz\"\n    # -- Address to bind the health check endpoint.\n    # It is better to set this option to the internal node address\n    # if the ingress nginx controller is running in the `hostNetwork: true` mode.\n    healthCheckHost: \"\"\n    # -- Annotations to be added to controller pods\n    ##\n    podAnnotations: {}\n    replicaCount: 1\n    # -- Define either 'minAvailable' or 'maxUnavailable', never both.\n    minAvailable: 1\n    # -- Define either 'minAvailable' or 'maxUnavailable', never both.\n    # maxUnavailable: 1\n\n    ## Define requests resources to avoid probe issues due to CPU utilization in busy nodes\n    ## ref: https://github.com/kubernetes/ingress-nginx/issues/4735#issuecomment-551204903\n    ## Ideally, there should be no limits.\n    ## https://engineering.indeedblog.com/blog/2019/12/cpu-throttling-regression-fix/\n    resources:\n        ##  limits:\n        ##    cpu: 100m\n        ##    memory: 90Mi\n        requests:\n            cpu: 100m\n            memory: 90Mi\n    # Mutually exclusive with keda autoscaling\n    autoscaling:\n        apiVersion: autoscaling/v2\n        enabled: false\n        annotations: {}\n        minReplicas: 1\n        maxReplicas: 11\n        targetCPUUtilizationPercentage: 50\n        targetMemoryUtilizationPercentage: 50\n        behavior: {}\n        # scaleDown:\n        #   stabilizationWindowSeconds: 300\n        #   policies:\n        #   - type: Pods\n        #     value: 1\n        #     periodSeconds: 180\n        # scaleUp:\n        #   stabilizationWindowSeconds: 300\n        #   policies:\n        #   - type: Pods\n        #     value: 2\n        #     periodSeconds: 60\n    autoscalingTemplate: []\n    # Custom or additional autoscaling metrics\n    # ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-custom-metrics\n    # - type: Pods\n    #   pods:\n    #     metric:\n    #       name: nginx_ingress_controller_nginx_process_requests_total\n    #     target:\n    #       type: AverageValue\n    #       averageValue: 10000m\n\n    # Mutually exclusive with hpa autoscaling\n    keda:\n        apiVersion: \"keda.sh/v1alpha1\"\n        ## apiVersion changes with keda 1.x vs 2.x\n        ## 2.x = keda.sh/v1alpha1\n        ## 1.x = keda.k8s.io/v1alpha1\n        enabled: false\n        minReplicas: 1\n        maxReplicas: 11\n        pollingInterval: 30\n        cooldownPeriod: 300\n        restoreToOriginalReplicaCount: false\n        scaledObject:\n            annotations: {}\n            # Custom annotations for ScaledObject resource\n            #  annotations:\n            # key: value\n        triggers: []\n        #     - type: prometheus\n        #       metadata:\n        #         serverAddress: http://\u003cprometheus-host\u003e:9090\n        #         metricName: http_requests_total\n        #         threshold: '100'\n        #         query: sum(rate(http_requests_total{deployment=\"my-deployment\"}[2m]))\n\n        behavior: {}\n    #     scaleDown:\n    #       stabilizationWindowSeconds: 300\n    #       policies:\n    #       - type: Pods\n    #         value: 1\n    #         periodSeconds: 180\n    #     scaleUp:\n    #       stabilizationWindowSeconds: 300\n    #       policies:\n    #       - type: Pods\n    #         value: 2\n    #         periodSeconds: 60\n\n    # -- Enable mimalloc as a drop-in replacement for malloc.\n    ## ref: https://github.com/microsoft/mimalloc\n    ##\n    enableMimalloc: true\n    ## Override NGINX template\n    customTemplate:\n        configMapName: \"\"\n        configMapKey: \"\"\n    service:\n        enabled: true\n        # -- If enabled is adding an appProtocol option for Kubernetes service. An appProtocol field replacing annotations that were\n        # using for setting a backend protocol. Here is an example for AWS: service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http\n        # It allows choosing the protocol for each backend specified in the Kubernetes service.\n        # See the following GitHub issue for more details about the purpose: https://github.com/kubernetes/kubernetes/issues/40244\n        # Will be ignored for Kubernetes versions older than 1.20\n        ##\n        appProtocol: true\n        annotations: {}\n        labels: {}\n        # clusterIP: \"\"\n\n        # -- List of IP addresses at which the controller services are available\n        ## Ref: https://kubernetes.io/docs/user-guide/services/#external-ips\n        ##\n        externalIPs: []\n        # -- Used by cloud providers to connect the resulting `LoadBalancer` to a pre-existing static IP according to https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer\n        loadBalancerIP: \"\"\n        loadBalancerSourceRanges: []\n        enableHttp: true\n        enableHttps: true\n        ## Set external traffic policy to: \"Local\" to preserve source IP on providers supporting it.\n        ## Ref: https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-typeloadbalancer\n        # externalTrafficPolicy: \"\"\n\n        ## Must be either \"None\" or \"ClientIP\" if set. Kubernetes will default to \"None\".\n        ## Ref: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies\n        # sessionAffinity: \"\"\n\n        ## Specifies the health check node port (numeric port number) for the service. If healthCheckNodePort isn’t specified,\n        ## the service controller allocates a port from your cluster’s NodePort range.\n        ## Ref: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip\n        # healthCheckNodePort: 0\n\n        # -- Represents the dual-stack-ness requested or required by this Service. Possible values are\n        # SingleStack, PreferDualStack or RequireDualStack.\n        # The ipFamilies and clusterIPs fields depend on the value of this field.\n        ## Ref: https://kubernetes.io/docs/concepts/services-networking/dual-stack/\n        ipFamilyPolicy: \"SingleStack\"\n        # -- List of IP families (e.g. IPv4, IPv6) assigned to the service. This field is usually assigned automatically\n        # based on cluster configuration and the ipFamilyPolicy field.\n        ## Ref: https://kubernetes.io/docs/concepts/services-networking/dual-stack/\n        ipFamilies:\n            - IPv4\n        ports:\n            http: 80\n            https: 443\n        targetPorts:\n            http: http\n            https: https\n        type: LoadBalancer\n        ## type: NodePort\n        ## nodePorts:\n        ##   http: 32080\n        ##   https: 32443\n        ##   tcp:\n        ##     8080: 32808\n        nodePorts:\n            http: \"\"\n            https: \"\"\n            tcp: {}\n            udp: {}\n        external:\n            enabled: true\n        internal:\n            # -- Enables an additional internal load balancer (besides the external one).\n            enabled: false\n            # -- Annotations are mandatory for the load balancer to come up. Varies with the cloud service.\n            annotations: {}\n            # loadBalancerIP: \"\"\n\n            # -- Restrict access For LoadBalancer service. Defaults to 0.0.0.0/0.\n            loadBalancerSourceRanges: []\n            ## Set external traffic policy to: \"Local\" to preserve source IP on\n            ## providers supporting it\n            ## Ref: https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-typeloadbalancer\n            # externalTrafficPolicy: \"\"\n    # shareProcessNamespace enables process namespace sharing within the pod.\n    # This can be used for example to signal log rotation using `kill -USR1` from a sidecar.\n    shareProcessNamespace: false\n    # -- Additional containers to be added to the controller pod.\n    # See https://github.com/lemonldap-ng-controller/lemonldap-ng-controller as example.\n    extraContainers: []\n    #  - name: my-sidecar\n    #    image: nginx:latest\n    #  - name: lemonldap-ng-controller\n    #    image: lemonldapng/lemonldap-ng-controller:0.2.0\n    #    args:\n    #      - /lemonldap-ng-controller\n    #      - --alsologtostderr\n    #      - --configmap=$(POD_NAMESPACE)/lemonldap-ng-configuration\n    #    env:\n    #      - name: POD_NAME\n    #        valueFrom:\n    #          fieldRef:\n    #            fieldPath: metadata.name\n    #      - name: POD_NAMESPACE\n    #        valueFrom:\n    #          fieldRef:\n    #            fieldPath: metadata.namespace\n    #    volumeMounts:\n    #    - name: copy-portal-skins\n    #      mountPath: /srv/var/lib/lemonldap-ng/portal/skins\n\n    # -- Additional volumeMounts to the controller main container.\n    extraVolumeMounts: []\n    #  - name: copy-portal-skins\n    #   mountPath: /var/lib/lemonldap-ng/portal/skins\n\n    # -- Additional volumes to the controller pod.\n    extraVolumes: []\n    #  - name: copy-portal-skins\n    #    emptyDir: {}\n\n    # -- Containers, which are run before the app containers are started.\n    extraInitContainers: []\n    # - name: init-myservice\n    #   image: busybox\n    #   command: ['sh', '-c', 'until nslookup myservice; do echo waiting for myservice; sleep 2; done;']\n\n    # -- Modules, which are mounted into the core nginx image. See values.yaml for a sample to add opentelemetry module\n    extraModules: []\n    #   containerSecurityContext:\n    #     allowPrivilegeEscalation: false\n    #\n    # The image must contain a `/usr/local/bin/init_module.sh` executable, which\n    # will be executed as initContainers, to move its config files within the\n    # mounted volume.\n\n    opentelemetry:\n        enabled: false\n        image: registry.k8s.io/ingress-nginx/opentelemetry:v20230107-helm-chart-4.4.2-2-g96b3d2165@sha256:331b9bebd6acfcd2d3048abbdd86555f5be76b7e3d0b5af4300b04235c6056c9\n        containerSecurityContext:\n            allowPrivilegeEscalation: false\n    admissionWebhooks:\n        annotations: {}\n        # ignore-check.kube-linter.io/no-read-only-rootfs: \"This deployment needs write access to root filesystem\".\n\n        ## Additional annotations to the admission webhooks.\n        ## These annotations will be added to the ValidatingWebhookConfiguration and\n        ## the Jobs Spec of the admission webhooks.\n        enabled: true\n        # -- Additional environment variables to set\n        extraEnvs: []\n        # extraEnvs:\n        #   - name: FOO\n        #     valueFrom:\n        #       secretKeyRef:\n        #         key: FOO\n        #         name: secret-resource\n        # -- Admission Webhook failure policy to use\n        failurePolicy: Fail\n        # timeoutSeconds: 10\n        port: 8443\n        certificate: \"/usr/local/certificates/cert\"\n        key: \"/usr/local/certificates/key\"\n        namespaceSelector: {}\n        objectSelector: {}\n        # -- Labels to be added to admission webhooks\n        labels: {}\n        # -- Use an existing PSP instead of creating one\n        existingPsp: \"\"\n        networkPolicyEnabled: false\n        service:\n            annotations: {}\n            # clusterIP: \"\"\n            externalIPs: []\n            # loadBalancerIP: \"\"\n            loadBalancerSourceRanges: []\n            servicePort: 443\n            type: ClusterIP\n        createSecretJob:\n            securityContext:\n                allowPrivilegeEscalation: false\n            resources: {}\n            # limits:\n            #   cpu: 10m\n            #   memory: 20Mi\n            # requests:\n            #   cpu: 10m\n            #   memory: 20Mi\n        patchWebhookJob:\n            securityContext:\n                allowPrivilegeEscalation: false\n            resources: {}\n        patch:\n            enabled: true\n            image:\n                registry: registry.k8s.io\n                image: ingress-nginx/kube-webhook-certgen\n                ## for backwards compatibility consider setting the full image url via the repository value below\n                ## use *either* current default registry/image or repository format or installing chart by providing the values.yaml will fail\n                ## repository:\n                tag: v20220916-gd32f8c343\n                digest: sha256:39c5b2e3310dc4264d638ad28d9d1d96c4cbb2b2dcfb52368fe4e3c63f61e10f\n                pullPolicy: IfNotPresent\n            # -- Provide a priority class name to the webhook patching job\n            ##\n            priorityClassName: \"\"\n            podAnnotations: {}\n            nodeSelector:\n                kubernetes.io/os: linux\n            tolerations: []\n            # -- Labels to be added to patch job resources\n            labels: {}\n            securityContext:\n                runAsNonRoot: true\n                runAsUser: 2000\n                fsGroup: 2000\n        # Use certmanager to generate webhook certs\n        certManager:\n            enabled: false\n            # self-signed root certificate\n            rootCert:\n                # default to be 5y\n                duration: \"\"\n            admissionCert:\n                # default to be 1y\n                duration: \"\"\n                # issuerRef:\n                #   name: \"issuer\"\n                #   kind: \"ClusterIssuer\"\n    metrics:\n        port: 10254\n        portName: metrics\n        # if this port is changed, change healthz-port: in extraArgs: accordingly\n        enabled: false\n        service:\n            annotations: {}\n            # prometheus.io/scrape: \"true\"\n            # prometheus.io/port: \"10254\"\n            # -- Labels to be added to the metrics service resource\n            labels: {}\n            # clusterIP: \"\"\n\n            # -- List of IP addresses at which the stats-exporter service is available\n            ## Ref: https://kubernetes.io/docs/user-guide/services/#external-ips\n            ##\n            externalIPs: []\n            # loadBalancerIP: \"\"\n            loadBalancerSourceRanges: []\n            servicePort: 10254\n            type: ClusterIP\n            # externalTrafficPolicy: \"\"\n            # nodePort: \"\"\n        serviceMonitor:\n            enabled: false\n            additionalLabels: {}\n            ## The label to use to retrieve the job name from.\n            ## jobLabel: \"app.kubernetes.io/name\"\n            namespace: \"\"\n            namespaceSelector: {}\n            ## Default: scrape .Release.Namespace only\n            ## To scrape all, use the following:\n            ## namespaceSelector:\n            ##   any: true\n            scrapeInterval: 30s\n            # honorLabels: true\n            targetLabels: []\n            relabelings: []\n            metricRelabelings: []\n        prometheusRule:\n            enabled: false\n            additionalLabels: {}\n            # namespace: \"\"\n            rules: []\n            # # These are just examples rules, please adapt them to your needs\n            # - alert: NGINXConfigFailed\n            #   expr: count(nginx_ingress_controller_config_last_reload_successful == 0) \u003e 0\n            #   for: 1s\n            #   labels:\n            #     severity: critical\n            #   annotations:\n            #     description: bad ingress config - nginx config test failed\n            #     summary: uninstall the latest ingress changes to allow config reloads to resume\n            # - alert: NGINXCertificateExpiry\n            #   expr: (avg(nginx_ingress_controller_ssl_expire_time_seconds) by (host) - time()) \u003c 604800\n            #   for: 1s\n            #   labels:\n            #     severity: critical\n            #   annotations:\n            #     description: ssl certificate(s) will expire in less then a week\n            #     summary: renew expiring certificates to avoid downtime\n            # - alert: NGINXTooMany500s\n            #   expr: 100 * ( sum( nginx_ingress_controller_requests{status=~\"5.+\"} ) / sum(nginx_ingress_controller_requests) ) \u003e 5\n            #   for: 1m\n            #   labels:\n            #     severity: warning\n            #   annotations:\n            #     description: Too many 5XXs\n            #     summary: More than 5% of all requests returned 5XX, this requires your attention\n            # - alert: NGINXTooMany400s\n            #   expr: 100 * ( sum( nginx_ingress_controller_requests{status=~\"4.+\"} ) / sum(nginx_ingress_controller_requests) ) \u003e 5\n            #   for: 1m\n            #   labels:\n            #     severity: warning\n            #   annotations:\n            #     description: Too many 4XXs\n            #     summary: More than 5% of all requests returned 4XX, this requires your attention\n    # -- Improve connection draining when ingress controller pod is deleted using a lifecycle hook:\n    # With this new hook, we increased the default terminationGracePeriodSeconds from 30 seconds\n    # to 300, allowing the draining of connections up to five minutes.\n    # If the active connections end before that, the pod will terminate gracefully at that time.\n    # To effectively take advantage of this feature, the Configmap feature\n    # worker-shutdown-timeout new value is 240s instead of 10s.\n    ##\n    lifecycle:\n        preStop:\n            exec:\n                command:\n                    - /wait-shutdown\n    priorityClassName: \"\"\n# -- Rollback limit\n##\nrevisionHistoryLimit: 10\n## Default 404 backend\n##\ndefaultBackend:\n    ##\n    enabled: false\n    name: defaultbackend\n    image:\n        registry: registry.k8s.io\n        image: defaultbackend-amd64\n        ## for backwards compatibility consider setting the full image url via the repository value below\n        ## use *either* current default registry/image or repository format or installing chart by providing the values.yaml will fail\n        ## repository:\n        tag: \"1.5\"\n        pullPolicy: IfNotPresent\n        # nobody user -\u003e uid 65534\n        runAsUser: 65534\n        runAsNonRoot: true\n        readOnlyRootFilesystem: true\n        allowPrivilegeEscalation: false\n    # -- Use an existing PSP instead of creating one\n    existingPsp: \"\"\n    extraArgs: {}\n    serviceAccount:\n        create: true\n        name: \"\"\n        automountServiceAccountToken: true\n    # -- Additional environment variables to set for defaultBackend pods\n    extraEnvs: []\n    port: 8080\n    ## Readiness and liveness probes for default backend\n    ## Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/\n    ##\n    livenessProbe:\n        failureThreshold: 3\n        initialDelaySeconds: 30\n        periodSeconds: 10\n        successThreshold: 1\n        timeoutSeconds: 5\n    readinessProbe:\n        failureThreshold: 6\n        initialDelaySeconds: 0\n        periodSeconds: 5\n        successThreshold: 1\n        timeoutSeconds: 5\n    # -- The update strategy to apply to the Deployment or DaemonSet\n    ##\n    updateStrategy: {}\n    #  rollingUpdate:\n    #    maxUnavailable: 1\n    #  type: RollingUpdate\n\n    # -- `minReadySeconds` to avoid killing pods before we are ready\n    ##\n    minReadySeconds: 0\n    # -- Node tolerations for server scheduling to nodes with taints\n    ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/\n    ##\n    tolerations: []\n    #  - key: \"key\"\n    #    operator: \"Equal|Exists\"\n    #    value: \"value\"\n    #    effect: \"NoSchedule|PreferNoSchedule|NoExecute(1.6 only)\"\n\n    affinity: {}\n    # -- Security Context policies for controller pods\n    # See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for\n    # notes on enabling and using sysctls\n    ##\n    podSecurityContext: {}\n    # -- Security Context policies for controller main container.\n    # See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for\n    # notes on enabling and using sysctls\n    ##\n    containerSecurityContext: {}\n    # -- Labels to add to the pod container metadata\n    podLabels: {}\n    #  key: value\n\n    # -- Node labels for default backend pod assignment\n    ## Ref: https://kubernetes.io/docs/user-guide/node-selection/\n    ##\n    nodeSelector:\n        kubernetes.io/os: linux\n    # -- Annotations to be added to default backend pods\n    ##\n    podAnnotations: {}\n    replicaCount: 1\n    minAvailable: 1\n    resources: {}\n    # limits:\n    #   cpu: 10m\n    #   memory: 20Mi\n    # requests:\n    #   cpu: 10m\n    #   memory: 20Mi\n\n    extraVolumeMounts: []\n    ## Additional volumeMounts to the default backend container.\n    #  - name: copy-portal-skins\n    #   mountPath: /var/lib/lemonldap-ng/portal/skins\n\n    extraVolumes: []\n    ## Additional volumes to the default backend pod.\n    #  - name: copy-portal-skins\n    #    emptyDir: {}\n\n    autoscaling:\n        apiVersion: autoscaling/v2\n        annotations: {}\n        enabled: false\n        minReplicas: 1\n        maxReplicas: 2\n        targetCPUUtilizationPercentage: 50\n        targetMemoryUtilizationPercentage: 50\n    service:\n        annotations: {}\n        # clusterIP: \"\"\n\n        # -- List of IP addresses at which the default backend service is available\n        ## Ref: https://kubernetes.io/docs/user-guide/services/#external-ips\n        ##\n        externalIPs: []\n        # loadBalancerIP: \"\"\n        loadBalancerSourceRanges: []\n        servicePort: 80\n        type: ClusterIP\n    priorityClassName: \"\"\n    # -- Labels to be added to the default backend resources\n    labels: {}\n## Enable RBAC as per https://github.com/kubernetes/ingress-nginx/blob/main/docs/deploy/rbac.md and https://github.com/kubernetes/ingress-nginx/issues/266\nrbac:\n    create: true\n    scope: false\n## If true, create \u0026 use Pod Security Policy resources\n## https://kubernetes.io/docs/concepts/policy/pod-security-policy/\npodSecurityPolicy:\n    enabled: false\nserviceAccount:\n    create: true\n    name: \"\"\n    automountServiceAccountToken: true\n    # -- Annotations for the controller service account\n    annotations: {}\n# -- Optional array of imagePullSecrets containing private registry credentials\n## Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/\nimagePullSecrets: []\n# - name: secretName\n\n# -- TCP service key-value pairs\n## Ref: https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/exposing-tcp-udp-services.md\n##\ntcp: {}\n#  8080: \"default/example-tcp-svc:9000\"\n\n# -- UDP service key-value pairs\n## Ref: https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/exposing-tcp-udp-services.md\n##\nudp: {}\n#  53: \"kube-system/kube-dns:53\"\n\n# -- Prefix for TCP and UDP ports names in ingress controller service\n## Some cloud providers, like Yandex Cloud may have a requirements for a port name regex to support cloud load balancer integration\nportNamePrefix: \"\"\n# -- (string) A base64-encoded Diffie-Hellman parameter.\n# This can be generated with: `openssl dhparam 4096 2\u003e /dev/null | base64`\n## Ref: https://github.com/kubernetes/ingress-nginx/tree/main/docs/examples/customization/ssl-dh-param\ndhParam:\n"
            ],
            "verify": false,
            "version": "4.5.2",
            "wait": true,
            "wait_for_jobs": false
          },
          "sensitive_attributes": [],
          "private": "eyJzY2hlbWFfdmVyc2lvbiI6IjEifQ==",
          "dependencies": [
            "data.aws_eks_cluster.demo",
            "kubernetes_namespace.nginx-namespace",
            "time_sleep.wait_for_kubernetes"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "kubernetes_namespace",
      "name": "nginx-namespace",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "nginx-ingress",
            "metadata": [
              {
                "annotations": null,
                "generate_name": "",
                "generation": 0,
                "labels": null,
                "name": "nginx-ingress",
                "resource_version": "335324",
                "uid": "d35fc434-e94a-4392-801f-bdab9b95a196"
              }
            ],
            "timeouts": null
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiZGVsZXRlIjozMDAwMDAwMDAwMDB9fQ==",
          "dependencies": [
            "data.aws_eks_cluster.demo",
            "time_sleep.wait_for_kubernetes"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "time_sleep",
      "name": "wait_for_kubernetes",
      "provider": "provider[\"registry.terraform.io/hashicorp/time\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "create_duration": "20s",
            "destroy_duration": null,
            "id": "2023-03-18T22:10:33Z",
            "triggers": null
          },
          "sensitive_attributes": [],
          "dependencies": [
            "data.aws_eks_cluster.demo"
          ]
        }
      ]
    }
  ],
  "check_results": null
}
